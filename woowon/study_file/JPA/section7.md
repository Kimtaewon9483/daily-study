# section7

### 프록시
- em.find() : DB를 통해서 실제 엔티티 객체를 조회
- em.getReference() : DB 조회를 미루는 가짜(프록시) 엔티티 객체 조회
    - 가짜 엔티티를 반환
    - target이 진짜 레퍼런스를 가르침, 초기에는 없다
- 실제 클래스를 상속받아서 만들어진다
    - 실제 클래스와 겉 모양이 같다
    - 사용하는 입장에서는 프록시 객체인지 구분하지 않고 사용하면 된다
    - 프록시 객체는 실제 객체의 참조(target)를 보관
    - 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출
    - 실제 객체가 필요하다면 영속성 컨텍스트를 통해 DB에 값을 가져와 실제 엔티티를 생성하고 target으로 연결해준다
        - 한번연결되면 사용가능, 초기화를 다시 하지 않아도 된다
- 프록시 객체는 처음 사용할때 한번만 초기화
- 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것이 아닌 프록시 객체를 통해 실제 엔티티에 접근이 가능한것이다
- 프록시 객체는 원본 엔티티를 상속받는다, 타입 체크시 주의해야한다(==비교대신 instance of를 사용해야한다)
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환한다, 반대도 마찬가지
- 영속성 컨텍스트에 도움을 받을 수 없는 준영속 상태일때, 프록시를 초기화하면 문제가 발생

### 즉시로딩, 지연로딩
- MEMBER -> TEAM
- LAZY(지연로딩)
    - em.find로 MEMBER를 가져왔을때 LAZY로 세팅이 되어있다면 MEMBER -> TEAM을 가짜 프록시 객체를 박아두고 TEMA 값을 사용하는 시점에 쿼리가 나간다
- EAGER(즉시로딩)
    - 프록시가 필요없다
    - MEMBER조회시 항상 TEAM도 조회한다
- 가급적 지연 로딩만 사용
- 즉시 로딩을 적용하면 예상치 못한 SQL이 발생한다
    - JPQL에서 N+1 문제를 일으킨다
- @ManyToOne, @OneToOne은 기본이 즉시 로딩
    - @OneToMany, @ManyToMany는 기본이 지연 로딩

### 영속성전의(CASCADE)
- 특정엔티티를 영속상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을떄
    - 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장
- 지연로딩,즉시로딩과 관련 없음
- 연관관계를 매핑하는 것과 관련 없음
- 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편라함을 제공
- CascadeType.option
    - ALL : 모두 적용
    - PERSIST : 영속
    - REMOVE : 삭제
    - MERGE : 병합
    - REFRESH : REFRESH
    - DETACH : DETACH
### 고아객체
- 고아 객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
- orphanRemoval = true
- Parent parent1 = em.find(Parent.class, id);
    - parent1.getChildren().remove(0);
- 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제가능
- 참조하는 곳이 하나일 떄 사용해야한다
- 특정 엔티티가 개인 소유할 때 사용
- @OneToOne, @OneToMany만 가능하다
- 영속성 전이 + 고아객체
    - CascadeType.All + orphanRemovel=true
    - 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거
    - 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있음
    
